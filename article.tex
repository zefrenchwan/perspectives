\documentclass{article}

\title{Moteur}
\author{zefrenchwan}
\date{version du \today{}}

\usepackage[french]{babel}
\usepackage{amsfonts,amsmath,amssymb}

\begin{document}
\maketitle
\abstract{Cet article propose un outil de modélisation applicable sur les systèmes sociaux par analogie avec les  systèmes physiques. Après avoir reformulé les concepts de base de la mécanique Newtonienne, nous proposons une version discrète sous forme de graphes dynamique. }

\section{Modèle de gestion d'états d'un système}

Un observateur modélise une situation d'objets variant au sein d'un système. Ce dernier définit des contraintes, en tous cas des liens, entre les objets. La question peut être la prédiction des futurs états, l'explication du passé du système ou l'optimisation du comportement d'un objet en particulier. Nous allons proposer une modélisation générale pour passer d'un modèle à une trajectoire dans un espace d'états. 


\subsection{Le modèle d'états continus}

Prenons un exemple classique : des objets physiques sont représentés comme des masses ponctuelles. 
On se donne un repère $R$ dans un espace de dimension $N=3$ (hormis le temps).
Pour chacune, des forces de gravitation s'appliquent, soumettant chacun à une résultante $\vec{F}$. 
Dès lors, on applique la mécanique Newtonienne : $$\vec{F} = \frac{d\vec{P}}{dt}$$
On peut réaliser une simulation physique de la manière suivante, en fixant un pas $\Delta t > 0$ : 
\begin{enumerate}
\item définir un instant initial $t_0$
\item pour chaque élément $e$ du système, ajouter $e$ dans l'espace avec une position initiale et une quantité de mouvement 
\item pour chaque pas de temps : calculer la force appliquée sur $e$, formant une résultante $R_e$, appliquer $\Delta \vec{P}_e = \vec{R_e} \Delta t$, et finalement mettre à jour la position et la quantité de mouvement de l'élément $e$ 
\end{enumerate}

Si l'on reprend la formalisation précédente, on peut garder la même logique générale, disons l'algorithme. 
Cependant, on peut aussi écrire, dans un premier temps, $\Delta \vec{P}_e = I_N \vec{R_e} \Delta t$ avec $I_N$ la matrice identité. 
Le changement est mathématiquement équivalent, mais il est le prélude à une notion plus avancée : avoir un terme dépendant du point d'espace où est un élément. 

 
Formellement, on peut alors passer à quelque chose de plus général. 
On se donne un système physique qu'on décrit comme des objets $(o_i)_{i \in I}$ avec $I \neq \emptyset$. 
Chaque objet $o_i$ est décrit via un état $E_i$ variable dans le temps. 
Ainsi, au temps $t$, on a un vecteur $E_{it}$ dans un espace vectoriel de dimension $v$.
Pour ce moment $t$, et tout couple $(i,j) \in I^2$, on a un vecteur d'interaction $c_{ij}^t$ dans cet espace. 
Ainsi, pour un élément $o_i$ à un temps $t$, on a un ensemble de changements dont la résultante est $\mathcal{R}_{it}$ (qu'on avait noté $R_e$). 
Reste à expliquer la variation d'état $\Delta E_{it}$, et pas seulement comme un $\mathcal{R}_{it} \Delta t$.
C'est le rôle d'une transformation $M_{it}$ qui est pour le moment une matrice de taille $v \times v$. 
Elle s'interprète par analogie avec le tenseur métrique en relativité générale, qui définit la géométrie locale de l'espace et détermine comment une impulsion se traduit en mouvement selon la courbure de l'environnement.
On a alors $$\mathcal{R}_{it} \Delta t = M_{it} \Delta E_{it}$$
Cette forme est intéressante parce qu'elle donne une base pour arriver à une notion abstraite d'espace d'états. 
$$\text{}$$

\begin{tabular}{|l|l|l|}
	\hline 
	Concept & Cas classique & Généralisation \\
	\hline 
	\hline 
	Changement & Force & Tout élément vectorisable \\
	\hline 
	Résultante & Somme des forces & Fonction de réduction \\
	\hline 
	Fonction locale & Géométrie locale & Matrice d'états \\
	\hline 
	Indicateur & Quantité de mouvement & État vectorisé \\
	           & et position & \\
	\hline 
\end{tabular}
$$\text{}$$
Ainsi, le principe est de prendre un espace d'états, donc un espace vectoriel de dimension finie. 
Les changements peuvent être typés de n'importe quelle classe, tant que l'on sait produire une résultante sous forme de vecteur. 
Alors $\mathcal{R}_{it}$ est la résultante des changements subis par $o_i$ à $t$. 
Pour lier les deux, la formule générale est $$R_{it} \Delta t = M_{it} \Delta E_{it}$$
Avec $M_{it}$ une matrice (dépendant de l'état de $o_i$ et du temps $t$). 
Celle ci s'interprète comme la prise en compte de l'état dans le changement. 
Par exemple, s'il n'y a aucune transformation ($M_{it} = I_v$ la matrice identité), le changement d'état est exactement expliqué par le produit de la durée et de la résultante. 
Les termes à gauche sont ce qui est relatif \`a la cause extérieure, les termes à droite sont ceux qui dépendent uniquement de l'état. Signalons au passage qu'il est tout à fait possible d'avoir une interaction réciproque de type : $$\Delta M_{it} = \Phi (\mathcal{R}_{it},E_{it}, \Delta t )$$
En terme physique, il est plus intéressant de le formuler en terme de $$E_{i,t+dt} = E_{it} + \Delta E_{it} = E_{it} + \Delta t M^{-1}_{it} R_{it} $$ mais cela implique des conditions sur $M_{it}$, évidemment qu'elle soit inversible pour commencer. 
$$\text{ }$$
En terme de "mode d'emploi" du modèle: 
\begin{enumerate}
	\item l'observateur perçoit un système dynamique composé des objets $(o_i)_{i \in I}$. Il sait observer, pour son temps $t$ à lui, les interactions de $o_i$ vers $o_j$ pour tout couple $(i,j) \in I$. 
	\item D'un point de vue formel, il connait donc $c_{ij}^t$ pour tout couple $(i,j) \in I^2$ et tout temps passé $t$. Chaque $c_{ij}^t$ est élément d'un ensemble $X$ dont la nature importe peu. 
	\item l'observateur modélise l'état des objets observés et les changements dans un même espace vectoriel de dimension $v$. Il dispose donc de fonctions de vectorisation. D'abord, s'il observe un état de l'objet $o_i$ à $t$, il sait le vectoriser dans $\mathbb{R}^v$ sous la forme d'une matrice de taille $v \times v$. Il calcule alors $M_{it}$. De même, s'il observe les changements $c_{ij}^t$, il dispose d'une fonction $\Phi_{it} : X^I \rightarrow \mathbb{R}^v$ (qui peut dépendre de $i$ et $t$). Il calcule alors $R_{it} = \Phi_{it}((c_{ij}^t)_{j \in I}) \in \mathbb{R}^v$. Par exemple, si $I$ est fini, les $c_{ij}^t$ sont des vecteurs et $\Phi_{it} = \sum_{j \in I}$ devient indépendant du temps et de l'objet. 
	\item il applique alors l'équation générale et trouve le $\Delta E_{it}$. Il peut appliquer une rétroaction sur la $M_{it}$ si son modèle l'exige. Enfin, il calcule le nouvel état. 
\end{enumerate}

\subsection{Graphe d'états}

Le modèle précédent a pour vocation de poser une logique d'états expliqués par des changements traités par un objet. 
Pour le rendre opérationnel et traitable par un programme informatique, nous proposons ici une implémentation basée sur un graphe dynamique. 

\begin{itemize}
	\item Les nœuds sont les objets à modéliser. Ils traitent des flux d'événements. Le graphe définit les objets (les noeuds) et les interactions autorisées (via les liens). Noeuds et liens peuvent avoir une durée de vie en dehors de laquelle ils n'opèrent tout simplement pas. 
	\item les liens sont orientés et définissent que la destination reçoit des flux d'événements de la source. La transmission n'est pas instantanée et prend une certaine latence $\delta t > 0$. Introduire ce délai permet d'éviter des boucles et introduit une forme de causalité. Si l'on prend toujours $\delta t = 1$, on simule un graphe "au tour par tour".
	\item chaque nœud reçoit un flux d'événements à un temps $t$. Le principe du modèle reste le même. Pour chacun d'eux : le flux entrant induit un changement d'état, ce nouvel état va être pris en compte pour produire un flux sortant en réponse, et cette réponse est envoyée aux suivants. Par exemple, si l'on formalise un réseau social dans lequel les utilisateurs s'échangent des messages, l'état peut représenter des caractéristiques telles que la tendance à partager du contenu (donc envoyer beaucoup d'événements), l'état émotionnel ou psychologique en fonction des caractéristiques des messages reçus. 
	\item deux formules sont le cœur mathématique du modèle. Les événements traités à l'instant $t$ par $i$ produisent une résultante $R_{it}$. Une matrice de sensibilité aux événements est attachée à chaque nœud : on note $S_{it} = M^{-1}_{it}$. On calcule alors $\Delta E_{it} =  S_{it} R_{it} \Delta t$ qui explique la variation d'état suite à la collecte et au traitement des événements. On calcule alors la réponse à apporter avec le nouvel état (par exemple, prise en compte de l'état émotionnel dans la réponse à apporter). Puis on transmet les événements produits en réponse.
	\item L'observateur peut alors dérouler une séquence d'événements observée en conditions réelles pour décrire l'état ou prévoir le comportement de chaque objet via le noeud correspondant. Il peut aussi, à l'inverse, chercher la séquence d'événements permettant d'orienter l'objet modélisé vers un certain état (comme par exemple dans un contexte de marketing digital).
\end{itemize} 
$$\text{}$$
Voici donc un tableau récapitulatif expliquant comment le graphe est un cas particulier du modèle général :

 
\begin{tabular}{|l|l|l|}
	\hline 
	Version modèle & Version graphe \\
	\hline 
	Objet & Nœud \\
	\hline 
	Espace des objets & Graphe des objets \\
	\hline 
	État dans le modèle & État dans une implémentation \\
	\hline 
	Variation d'état & Variation d'état (iso) \\
	\hline 
	Résultante des changements & Réaction aux événements \\
	\hline 
	Matrice des états & Sensibilité aux événements \\
	\hline
\end{tabular}
$$\text{}$$
Bien sûr, d'autres formes plus évoluées sont possibles: 
\begin{itemize}
	\item des liens qui sont enrichis de certaines caractéristiques (usure, par exemple). On peut les affubler d'un nombre d'événements maximum par unité de temps, ou une usure qui les désactive sous certaines conditions. 
	\item des liens qui filtrent les événements parce qu'ils ne sont pas sensibles à cette forme d'interaction, ou qui en atténuent l'intensité au fur et à mesure qu'ils voyagent. On aurait alors une perte d'intensité en fonction d'une distance. 
\end{itemize}
	

\end{document}