\documentclass{article}

\title{Vers un moteur de simulation sociale}
\author{zefrenchwan}
\date{version du \today{}}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsfonts,amsmath,amssymb}
\usepackage{float}

\begin{document}
\maketitle
\abstract{Nous avons chacun un point de vue sur notre système social, et nous passons notre temps à anticiper sa dynamique : ce qui sera fait, par qui, à quelle échéance. Cette capacité nous permet d'ajuster nos comportement au fur et à mesure, que ce soit tactiquement dans une situation donnée ou pour notre meilleur intérêt à plus long terme. La modélisation formelle d'un système social n'a rien de nouveau : elle est courante en politique (sondages, campagnes électorales), en marketing digital (maximiser l'impact d'une campagne) pour ne citer que celles ci. 	Cet article propose un outil de modélisation applicable sur les systèmes sociaux par analogie avec les  systèmes physiques. Après avoir reformulé les concepts de base de la mécanique Newtonienne, nous proposons une version discrète sous forme de graphes dynamique. }
\tableofcontents
\clearpage

\section{Vers une modélisation des systèmes sociaux}

Dans sa définition la plus générale, un système social est un ensemble d'entités évoluant au sein d'une structure d'interactions. Une entité peut être un individu, un groupe ou une institution, caractérisée par une identité stable et une durée de vie finie. Contrairement à un objet physique inerte, l'entité sociale est un acteur : elle comprend le monde de manière partielle et agit en fonction de buts spécifiques. Dès lors, chaque acteur met en œuvre avec des stratégies. Ce qu'il comprend du système, notamment des autres acteurs, est fonction des faits qu'il connait mais aussi, et surtout, de son point de vue sur le système. Un même événement peut donc déclencher des réactions opposées selon le prisme idéologique de l'acteur qui le reçoit. Si l'on isole les concepts centraux, on a donc ceci : 

\begin{table}[H]
\center
\begin{tabular}{|l|l|}
\hline 
Nom & Description \\
\hline 
Acteur & Toute entité active (qui agit) et réflexive (qui pense) \\
\hline 
Lien & Toute forme d'interaction ou de contrainte \\
\hline 
Système & Cadre dans lequel les acteurs s'organisent \\
 & en fonction des liens. \\
\hline 
Fait & Ce qui est observable ou objectivement vrai \\
\hline 
Vue & Point de vue sur une partie du système \\
 & (par opposition au fait qui est objectif) \\
\hline 
But & Ce qu'un acteur veut obtenir, être ou réaliser \\
\hline 
Stratégie & Actions ou solutions trouvées par un acteur pour \\
 & réaliser un but en propre ou au sein d'une alliance \\
\hline 
\end{tabular}
\caption{Principaux concepts d'un modèle social}
\end{table}

Le concept clé que ce document veut mettre en avant est le suivant : \textbf{les vues définissent le comportement des acteurs, les comportements des acteurs modifient le système, le système change les vues des acteurs}. 
Donc, un système social est en rétroaction permanente: 
\begin{enumerate}
	\item \textbf{Perception} : Les vues induisent des tensions.
	\item \textbf{Action} : Les tensions déclenchent des actions qui modifient le système (création ou rupture de liens).
	\item \textbf{Réaction} : La nouvelle structure du système modifie en retour la perception des acteurs. 
\end{enumerate}

$$\text{}$$
C'est tout ce qui fait la difficulté d'un modèle réellement pertinent : 
\begin{itemize}
	\item les acteurs communiquent rarement leurs vue et leur stratégie de manière exhaustive et transparente. Il faut donc l'approximer en observant les actes, ou l'estimer par rapport à leur logique de maximisation de leur propre intérêt (tel parti a un intérêt à une alliance pour placer ses candidats à telle élection). 
	\item les boucles de rétroaction permanentes amènent à des équations que l'on ne peut résoudre que sur des temps courts du fait de leur sensibilité aux conditions initiales. A supposer bien sûr que le système reste dans une configuration connue et mathématisable. 
	\item les événements inattendus ou difficiles à anticiper, les fameux cygnes noirs, sont une évidence : on sait qu'on en aura.
\end{itemize}

Aussi, soyons modestes, et disons le tout de suite : le social ne se laisse pas docilement prédire ainsi. Il faut donc distinguer plusieurs objectifs de précision en fonction de ce que l'observateur sait d'un système: 

\begin{enumerate}
	\item la prédiction définit de manière unique l'état suivant, ce qu'on va observer à coup sûr. 
	\item la prédiction fournit une distribution de probabilités, ou en tous cas la possibilité de décrire les prochains états en affirmant que celui ci est plus probable que celui là.
	\item la prédiction donne un ensemble des possibles, qui est une façon surtout de dire que les autres sont absolument impossibles. On restreint donc l'ensemble des possibles. 
\end{enumerate}

\begin{table}[H]
\center
\begin{tabular}{|l|l|}
\hline 
Niveau de prédiction & Description \\
\hline 
Déterministe & L'état suivant est connu \\
 & au fil du temps \\
\hline 
Probabiliste &  Les états suivants sont évaluables \\
 & suivant une distribution de probabilités \\
\hline 
Prospectif & On exclut les états impossibles \\
 & et on fournit des tendances à long terme \\
 \hline 
\end{tabular}
\caption{Niveaux de prédiction possibles}
\end{table}

\section{Modèle de gestion d'états d'un système}

Dans cette section, après une mise en garde nécessaire sur les limites de la modélisation, nous proposons une approche pour décrire mathématiquement la dynamique d'un système en général. Si nous avons en tête son applicabilité à un système social, la mécanique que nous proposons est en réalité plus générale. Nous allons donc nous placer du point de vue d'un observateur. Celui ci modélise une situation d'objets variant au sein d'un système. Ce dernier définit des contraintes, en tous cas des liens, entre les objets. La question peut être la prédiction des futurs états, l'explication du passé du système ou l'optimisation du comportement d'un objet en particulier. Nous allons proposer une modélisation générale pour passer d'un modèle à une trajectoire dans un espace d'états. 


\subsection{Le modèle d'états continus}

Prenons un exemple classique : des objets physiques sont représentés comme des masses ponctuelles. 
On se donne un repère $R$ dans un espace de dimension $N=3$ (hormis le temps).
Pour chacune, des forces de gravitation s'appliquent, soumettant chacun à une résultante $\vec{F}$. 
Dès lors, on applique la mécanique Newtonienne : $$\vec{F} = \frac{d\vec{P}}{dt}$$
On peut réaliser une simulation physique de la manière suivante, en fixant un pas $\Delta t > 0$ : 
\begin{enumerate}
\item définir un instant initial $t_0$
\item pour chaque élément $e$ du système, ajouter $e$ dans l'espace avec une position initiale et une quantité de mouvement 
\item pour chaque pas de temps : calculer la force appliquée sur $e$, formant une résultante $R_e$, appliquer $\Delta \vec{P}_e = \vec{R_e} \Delta t$, et finalement mettre à jour la position et la quantité de mouvement de l'élément $e$ 
\end{enumerate}

Si l'on reprend la formalisation précédente, on peut garder la même logique générale, disons l'algorithme. 
Cependant, on peut aussi écrire, dans un premier temps, $\Delta \vec{P}_e = I_N \vec{R_e} \Delta t$ avec $I_N$ la matrice identité. 
Le changement est mathématiquement équivalent, mais il est le prélude à une notion plus avancée : avoir un terme dépendant du point d'espace où est un élément. 

 
Formellement, on peut alors passer à quelque chose de plus général. 
On se donne un système physique qu'on décrit comme des objets $(o_i)_{i \in I}$ avec $I \neq \emptyset$. 
Chaque objet $o_i$ est décrit via un état $E_i$ variable dans le temps. 
Ainsi, au temps $t$, on a un vecteur $E_{it}$ dans un espace vectoriel de dimension $v$.
Pour ce moment $t$, et tout couple $(i,j) \in I^2$, on a un vecteur d'interaction $c_{ij}^t$ dans cet espace. 
Ainsi, pour un élément $o_i$ à un temps $t$, on a un ensemble de changements dont la résultante est $\mathcal{R}_{it}$ (qu'on avait noté $R_e$). 
Reste à expliquer la variation d'état $\Delta E_{it}$, et pas seulement comme un $\mathcal{R}_{it} \Delta t$.
C'est le rôle d'une transformation $M_{it}$ qui est pour le moment une matrice de taille $v \times v$. 
Elle s'interprète par analogie avec le tenseur métrique en relativité générale, qui définit la géométrie locale de l'espace et détermine comment une impulsion se traduit en mouvement selon la courbure de l'environnement.
On a alors $$\mathcal{R}_{it} \Delta t = M_{it} \Delta E_{it}$$
Cette forme est intéressante parce qu'elle donne une base pour arriver à une notion abstraite d'espace d'états. 

\begin{table}[H]
\center
\begin{tabular}{|l|l|l|}
	\hline 
	Concept & Cas classique & Généralisation \\
	\hline 
	\hline 
	Changement & Force & Tout élément vectorisable \\
	\hline 
	Résultante & Somme des forces & Fonction de réduction \\
	\hline 
	Fonction locale & Géométrie locale & Matrice d'états \\
	\hline 
	Indicateur & Quantité de mouvement & État vectorisé \\
	           & et position & \\
	\hline 
\end{tabular}
\caption{Sommaire de la généralisation des concepts physiques}
\end{table}
$$\text{}$$
Ainsi, le principe est de prendre un espace d'états, donc un espace vectoriel de dimension finie. 
Les changements peuvent être typés de n'importe quelle classe, tant que l'on sait produire une résultante sous forme de vecteur. 
Alors $\mathcal{R}_{it}$ est la résultante des changements subis par $o_i$ à $t$. 
Pour lier les deux, la formule générale est $$R_{it} \Delta t = M_{it} \Delta E_{it}$$
Avec $M_{it}$ une matrice (dépendant de l'état de $o_i$ et du temps $t$). 
Celle ci s'interprète comme la prise en compte de l'état dans le changement. 
Par exemple, s'il n'y a aucune transformation ($M_{it} = I_v$ la matrice identité), le changement d'état est exactement expliqué par le produit de la durée et de la résultante. 
Les termes à gauche sont ce qui est relatif \`a la cause extérieure, les termes à droite sont ceux qui dépendent uniquement de l'état. Signalons au passage qu'il est tout à fait possible d'avoir une interaction réciproque de type : $$\Delta M_{it} = \Phi (\mathcal{R}_{it},E_{it}, \Delta t )$$
En terme physique, il est plus intéressant de le formuler en terme de $$E_{i,t+dt} = E_{it} + \Delta E_{it} = E_{it} + \Delta t M^{-1}_{it} R_{it} $$ mais cela implique des conditions sur $M_{it}$, évidemment qu'elle soit inversible pour commencer. 
$$\text{ }$$
En terme de "mode d'emploi" du modèle: 
\begin{enumerate}
	\item l'observateur perçoit un système dynamique composé des objets $(o_i)_{i \in I}$. Il sait observer, pour son temps $t$ à lui, les interactions de $o_i$ vers $o_j$ pour tout couple $(i,j) \in I$. 
	\item D'un point de vue formel, il connait donc $c_{ij}^t$ pour tout couple $(i,j) \in I^2$ et tout temps passé $t$. Chaque $c_{ij}^t$ est élément d'un ensemble $X$ dont la nature importe peu. 
	\item l'observateur modélise l'état des objets observés et les changements dans un même espace vectoriel de dimension $v$. Il dispose donc de fonctions de vectorisation. D'abord, s'il observe un état de l'objet $o_i$ à $t$, il sait le vectoriser dans $\mathbb{R}^v$ sous la forme d'une matrice de taille $v \times v$. Il calcule alors $M_{it}$. De même, s'il observe les changements $c_{ij}^t$, il dispose d'une fonction $\Phi_{it} : X^I \rightarrow \mathbb{R}^v$ (qui peut dépendre de $i$ et $t$). Il calcule alors $R_{it} = \Phi_{it}((c_{ij}^t)_{j \in I}) \in \mathbb{R}^v$. Par exemple, si $I$ est fini, les $c_{ij}^t$ sont des vecteurs et $\Phi_{it} = \sum_{j \in I}$ devient indépendant du temps et de l'objet. 
	\item il applique alors l'équation générale et trouve le $\Delta E_{it}$. Il peut appliquer une rétroaction sur la $M_{it}$ si son modèle l'exige. Enfin, il calcule le nouvel état. 
\end{enumerate}

\subsection{Graphe d'états}

Le modèle précédent a pour vocation de poser une logique d'états expliqués par des changements traités par un objet. 
Pour le rendre opérationnel et traitable par un programme informatique, nous proposons ici une implémentation basée sur un graphe dynamique. 

\begin{itemize}
	\item Les nœuds sont les objets à modéliser. Ils traitent des flux d'événements. Le graphe définit les objets (les noeuds) et les interactions autorisées (via les liens). Noeuds et liens peuvent avoir une durée de vie en dehors de laquelle ils n'opèrent tout simplement pas. 
	\item les liens sont orientés et définissent que la destination reçoit des flux d'événements de la source. La transmission n'est pas instantanée et prend une certaine latence $\delta t > 0$. Introduire ce délai permet d'éviter des boucles et introduit une forme de causalité. Si l'on prend toujours $\delta t = 1$, on simule un graphe "au tour par tour".
	\item chaque nœud reçoit un flux d'événements à un temps $t$. Le principe du modèle reste le même. Pour chacun d'eux : le flux entrant induit un changement d'état, ce nouvel état va être pris en compte pour produire un flux sortant en réponse, et cette réponse est envoyée aux suivants. Par exemple, si l'on formalise un réseau social dans lequel les utilisateurs s'échangent des messages, l'état peut représenter des caractéristiques telles que la tendance à partager du contenu (donc envoyer beaucoup d'événements), l'état émotionnel ou psychologique en fonction des caractéristiques des messages reçus. 
	\item deux formules sont le cœur mathématique du modèle. Les événements traités à l'instant $t$ par $i$ produisent une résultante $R_{it}$. Une matrice de sensibilité aux événements est attachée à chaque nœud : on note $S_{it} = M^{-1}_{it}$. On calcule alors $\Delta E_{it} =  S_{it} R_{it} \Delta t$ qui explique la variation d'état suite à la collecte et au traitement des événements. On calcule alors la réponse à apporter avec le nouvel état (par exemple, prise en compte de l'état émotionnel dans la réponse à apporter). Puis on transmet les événements produits en réponse.
	\item L'observateur peut alors dérouler une séquence d'événements observée en conditions réelles pour décrire l'état ou prévoir le comportement de chaque objet via le noeud correspondant. Il peut aussi, à l'inverse, chercher la séquence d'événements permettant d'orienter l'objet modélisé vers un certain état (comme par exemple dans un contexte de marketing digital).
\end{itemize} 
$$\text{}$$
Voici donc un tableau récapitulatif expliquant comment le graphe est un cas particulier du modèle général :

\begin{table}[H]
\center
\begin{tabular}{|l|l|}
	\hline 
	Version modèle & Version graphe \\
	\hline 
	Objet & Nœud \\
	\hline 
	Espace des objets & Graphe des objets \\
	\hline 
	État dans le modèle & État dans une implémentation \\
	\hline 
	Variation d'état & Variation d'état (iso) \\
	\hline 
	Résultante des changements & Réaction aux événements \\
	\hline 
	Matrice des états & Sensibilité aux événements \\
	\hline
\end{tabular}
\caption{Passer du modèle général au cas discret}
\end{table}


Bien sûr, d'autres formes plus évoluées sont possibles: 
\begin{itemize}
	\item des liens qui sont enrichis de certaines caractéristiques (usure, par exemple). On peut les affubler d'un nombre d'événements maximum par unité de temps, ou une usure qui les désactive sous certaines conditions. 
	\item des liens qui filtrent les événements parce qu'ils ne sont pas sensibles à cette forme d'interaction, ou qui en atténuent l'intensité au fur et à mesure qu'ils voyagent. On aurait alors une perte d'intensité en fonction d'une distance. 
\end{itemize}


\subsection{Les mécanismes de rétroaction}

Voyons plus en détail les équations de changement d'état et les possibilités de rétroaction. L'observateur a donc choisi $v$ axes d'analyse qui résument les états des acteurs ainsi que les caractéristiques des événements qui les modifient. Soient donc $\alpha_1, \ldots, \alpha_v$ ces axes, et $[s_{np}]_{1\le n,p\le v}$ la matrice de sensibilité de l'acteur $o_i$ à l'instant $t$. Celui ci reçoit des événements dont la résultante est $[r_{it}^j]_{1\le j \le v}$. Si la matrice de sensibilité n'évolue pas, la même résultante donnera la même variation d'états. C'est exactement ce qu'on attend d'un objet physique, et c'est d'ailleurs un fait fondamental : les lois physiques sont les mêmes au fil du temps et en tout point d'espace. Les systèmes sociaux ne suivent évidemment pas cette même logique : il y a adaptation progressive, donc une forme d'apprentissage au fil du temps pour un acteur donné. Il existe plusieurs façons de le modéliser (règles d'Oja ou de Hebb) mais l'on peut écrire, par exemple : 
$$\displaystyle { S_{i,t+\Delta t} = S_{it} + \eta ( \Delta E_{it} \otimes \mathcal{R}_{it} ) \Delta t } $$
Soient $\Delta S_{it} = [\sigma_{np}]_{1 \le n,p \le v}$, $\mathcal{R}_{it} = [r_n]_{1 \le n \le v}$ le vecteur colonne résultante et $\Delta E_{it} = [\epsilon_n]_{1 \le n \le v}$ le vecteur colonne variation d'état. Alors, pour $n$ et $p$ fixés, il vient 
$$\sigma_{np} = \eta \times \epsilon_n  \times r_p \times \Delta t$$
Fixons $n$ et $p$ pour traiter valeur à valeur. La formule s'explique ainsi : 
\begin{enumerate}
	\item la sensibilité $s_{np}$ de l'acteur sur la ligne $n$ et la colonne $p$ s'interprète par l'action de l'axe $p$ sur l'axe $n$. Si $n = p$, c'est simplement la valeur sur l'axe en question. 
	\item sa variation $\sigma_{np}$ est ce qu'on va ajouter à $s_{np}$ pour obtenir la nouvelle matrice de sensibilité
	\item une capacité globale d'apprentissage $\eta$. C'est un réel compris entre 0 et 1. Plus il est élevé, plus l'acteur va changer son comportement et être influencé par l'événement. Dans un système physique sans rétroaction, on aura $\eta = 0$. 
	\item $\epsilon_n$ qui est la variation d'état sur l'axe $n$. C'est bien une variation. En effet, si l'état ne change pas, il n'y a pas de raison de modifier la sensibilité aux événements, donc d'apprendre. 
	\item $r_p$ qui est la résultante des événements sur l'axe $p$. Plus elle est forte sur cet axe, plus grande est l'impact sur $\sigma_{np}$
\end{enumerate}

\section{Limites du modèle et prise en compte des facteurs sociaux}

Le modèle précédent utilise des concepts physiques qu'il extrapole aux systèmes sociaux. Il souffre cependant de plusieurs points faibles majeurs que cette section propose de décrire et corriger : 
\begin{itemize}
	\item nous nous plaçons dans un contexte d'usage du modèle : l'observateur fournit lui même les axes. Il faudra questionner cet usage : un $v$ trop petit et l'on passe à côté de signaux subtils, et s'il est trop grand, il devient incalculable.
	\item les systèmes sociaux ne sont pas aussi linéaires et simples que les équations de changement d'état et de rétroaction laissent penser. Il nous faudra proposer des variations d'état et des modalités d'apprentissage plus réalistes
	\item la description physique vise à observer une dynamique d'états. Or, un acteur social n'est pas aussi observable : on ne connait pas son état avec une telle précision, on ne constate que ses interactions. Il faut donc revoir l'objectif de description de son état. 
\end{itemize}

\subsection{Les axes de modélisation ne sont pas évidents}

Dans un système social, les interactions sont riches, et le procédé de vectorisation des états et des événements va les réduire à $v$ axes. Si $v$ est vraiment petit, le risque de perte d'information est réel. Par exemple, réduire une communication de crise aux axes "colère" et "peur" ne permettra pas la détection de signaux faibles tels que la désobéissance civile par exemple.

De plus, si l'on prend des événements de type texte, passer d'un texte long à un vecteur est aisé, mais le retour du vecteur au texte pour la production de messages, en pratique quasiment infaisable. Une IA générative pourrait cependant être exploitée pour produire des messages textuels suivant un certain vecteur. 

\subsection{Les systèmes sociaux ne sont pas linéaires}

Les deux équations clé sont: 
\begin{align*} 
	\Delta E_{it} &=  S_{it} R_{it} \Delta t \\
	\Delta S_{it} &= \eta ( \Delta E_{it} \otimes \mathcal{R}_{it} ) \Delta t
\end{align*}

Elles souffrent d'un problème majeur dès que l'on sort du cadre physique. En l'état, si on multiplie la résultante par $\lambda$, le $\Delta E_{it}$ l'est aussi, et le $\Delta S_{it}$ est alors multiplié par $\lambda^2$. Or, si l'on prend le cas de la diffusion de messages dans les réseaux sociaux, on obtiendrait que si un message est $\lambda$ fois plus intense, il produit un effet chez son lecteur $\lambda$ fois plus fort, et ceci pour tout $\lambda$. C'est bien sûr faux en pratique. il faut prendre en compte deux phénomènes: 
\begin{itemize}
	\item la saturation de l'utilisateur : au delà d'un certain niveau sur un axe donné (disons la violence ou la viralité), l'utilisateur va saturer et traiter le message comme une forme de spam. La variation d'état ne peut pas être simplement linéaire, il faut la corriger
	\item l'apprentissage est aussi limité. Si la variation d'état est faible, la variation de la sensibilité peut être corrélée linéairement. Mais au delà d'une certaine intensité d'état (personne extrémiste) ou de variation demandée, il n'y a plus d'adaptation. 
\end{itemize}
$$\text{}$$
Il faut donc apporter deux corrections au modèle dès lors qu'on quitte la pure simulation physique. Nous proposons donc ceci: 
\begin{align*} 
	\Delta E_{it} &= \sigma( S_{it} R_{it} \Delta t )\\
	\Delta S_{it} &= \eta(\Delta E_{it}, \Delta t) \text{ } ( \Delta E_{it} \otimes \mathcal{R}_{it} ) \Delta t
\end{align*}
Avec : 
\begin{itemize}
	\item $\sigma$ une fonction d'ajustement de la variation d'état qui écrase les valeurs au delà d'un certain seuil. Une formule globale n'est pas le meilleur choix, car elle dépend souvent de la norme de $E_{it}$ ou sa variation. Elle est "trop brutale" au sens où elle impacte indifféremment des valeurs plausibles et des valeurs plus extrêmes. On utilisera plutôt une fonction vectorielle pour agir composante à composante : $\sigma = (\sigma_1, \ldots, \sigma_v)$. L'avantage est ce que si un axe $k$ a une valeur très élevée, la correction apportée ne se fera que sur $\sigma_k$.
	\item $\eta$ qui devient une fonction et plus seulement un nombre. Celle ci a le même rôle : limiter l'adaptation à un seuil raisonnable et prévenir les effets de saturation
\end{itemize}


\begin{table}[H]
	\center 
	\begin{tabular}{|l|l|}
		\hline 
		Facteur correctif & Utilité dans le modèle social \\
		\hline 
		$\sigma$ & Contraint un état à varier dans un voisinage \\
		 & raisonnable de son état courant \\
		\hline 
		$\eta$ variable & Contraint l'apprentissage à garder \\
		 & la sensibilité dans un voisinage raisonnable \\
		 & de sa valeur actuelle \\
		\hline 
	\end{tabular}
	\caption{Utilité et interprétation des valeurs correctives}
\end{table}

\subsection{On ne connait pas l'état des acteurs}

Si l'on reprend le modèle, on comprend que l'observateur fixe $v$ et ses axes de description de l'espace des états. Sur un système physique, en pratique, on connait les conditions de simulation, de sorte que : 
\begin{itemize}
	\item la description de l'état initial ne pose pas de difficulté particulière
	\item les lois de transformation sont connues : la résultante suit une logique mathématique, la matrice $M_{it}$ sont dictées par le modèle
	\item la question est donc plus le suivi de la trajectoire dans l'espace des états
\end{itemize}
$$\text{}$$
Dans une modélisation sociale, la description des états et la sensibilité est difficile. Ce qu'on connait le plus certainement reste : 
\begin{itemize}
	\item les axes d'analyse, donc $\mathbb{R}^v$
	\item la fonction de vectorisation de l'espace des événements vers $\mathbb{R}^v$ 
	\item la fonction de vectorisation de l'espace des états des acteurs vers $\mathbb{R}^v$ 
	\item pour chaque acteur indexé par $i \in I$, une série temporelle des événements entrants et sortants. On peut supposer qu'ils sont vectorisés, de sorte que l'on dispose des entrants $e^-$ et sortants $e^+$ dans $\mathbb{R}^v$ directement. Dans cette partie, on les notera $(e^{-}_{ik})_{1 \le k \le n}$ et $(e_{ik}^{+})_{1 \le k \le n}$. Dans la mesure où on calcule des résultantes, il y a autant d'entrants que de sortants, donc le $n$ est le même. Même si nous avons pris un indexage par un entier, on suppose disposer de la date exacte de collecte de la résultante. 
\end{itemize}
$$\text{}$$
Dans ce contexte, on pense l'acteur comme une "boite noire" : on ne connait rien a priori de son état interne ou de sa sensibilité. Si l'on peut cependant avoir un modèle opérationnel, il faut lier ce qu'il exprime à ce qu'il sait, donc poser, par exemple, que les événements sortants sont fonction de son état courant et des événements entrants. Autrement dit, il parait raisonnable de prendre une fonction $\Gamma_{it}: \mathbb{R}^v \times \mathbb{R}^v \rightarrow \mathbb{R}^v$ (dépendante de l'acteur et potentiellement du temps) telle que $$e^{+}_{it} = \Gamma_{it}(E_{it}, e^{-}_{it})$$
Il reste à poser des hypothèses qui rendent son usage plausible. Par exemple, une première approximation serait de décrire un événement sortant comme fonction de l'état courant ($A_{i}E_{it}$), de l'entrée reçue à ce moment là ($B_{it} e^{-}_{it}$) et d'un vecteur aléatoire de moyenne nulle (par exemple un bruit blanc gaussien). Ainsi, si on observe l'acteur $i$, on aurait pour tout $t$
$$e^{+}_{it} = A_{i}E_{it} + B_{it}e^{-}_{it} + C_{it}$$ 
Pour permettre de savoir comment l'acteur $i$ évolue dans le temps, on veut calculer la trajectoire de $E_{it}$ (comme fonction de $t$). Et pour que ce soit possible, on approxime $B_{it}$ comme une fonction de $B_i$ (matrice indépendante de $t$, dépendant de l'acteur $i$) et $e^{-}_{it}$. Une proposition peut être : $$\displaystyle{B_{it} = B_i \text{ }\frac{1}{1+ \lambda||e^{-}_{it}||}}$$ pour un certain paramètre d'amortissement $\lambda$. Plus l'événement entrant a une norme élevée, moins il est considéré comme pertinent et moins la réponse fournie en tiendra compte. Quant à $\lambda$, il est plus une constante technique pour ajuster la participation de $B_{it}$. Un retour critique de l'observateur est nécessaire : cette formule capture une forme de fatigue informationnelle mais est inadaptée quand l'événement est traumatique pour son acteur. Si par exemple, on applique l'outil à un contexte de crise (guerre), il faut adapter la formule pour ne prendre en compte que les événements les plus chargés émotionnellement. 

\end{document}
